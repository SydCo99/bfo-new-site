{"version":3,"file":"/dist/purecounter.js",
"mappings":"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",
"sources":["webpack://PureCounter/webpack/universalModuleDefinition", "webpack://PureCounter/./js/purecounter.js",
"webpack://PureCounter/./purecounter.js","webpack://PureCounter/webpack/bootstrap","webpack://PureCounter/webpack/runtime/define property getters","webpack://PureCounter/webpack/runtime/hasOwnProperty shorthand","webpack://PureCounter/webpack/startup"],
"sourcesContent":
["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PureCounter\"] = factory();\n\telse\n\t\troot[\"PureCounter\"] = factory();\n})(self, function() {\nreturn ","export default class PureCounter {\r\n    constructor(options = {}) {\r\n        /** Default configurations */\r\n        this.defaults = {\r\n            start: 0, // Starting number [uint]\r\n            end: 100, // End number [uint]\r\n            duration: 2000, // Count duration [milisecond]\r\n            delay: 10, // Count delay [milisecond]\r\n            once: true, // Counting at once or recount when scroll [boolean]\r\n            pulse: false, // Pulse count for certain time [boolean|milisecond]\r\n            decimals: 0, // Decimal places [uint]\r\n            legacy: true, // If this is true it will use the scroll event listener on browsers\r\n            filesizing: false, // Is it for filesize?\r\n            currency: false, // Is it for currency? Use it for set the symbol too [boolean|char|string]\r\n            separator: false, // Do you want to use thausands separator? use it for set the symbol too [boolean|char|string]\r\n            formater: \"us-US\", // Number toLocaleString locale/formater, by default is \"en-US\" [string|boolean:false]\r\n            selector: \".purecounter\", // HTML query selector for spesific element\r\n        };\r\n        /** Set default configuration based on user input */\r\n        this.configOptions = this.setOptions(options, this.defaults);\r\n        /** Get all elemenets based on default selector */\r\n        this.elements = document.querySelectorAll(this.configOptions.selector);\r\n        /** Get browser Intersection Listener Support */\r\n        this.intersectionSupport = this.intersectionListenerSupported();\r\n        /** Initiate event listened */\r\n        this.registerEventListeners();\r\n    }\r\n\r\n    /** This method is for create and merge configuration */\r\n    setOptions(config, baseConfig = {}) {\r\n        // Create new Config object;\r\n        var newConfig = {};\r\n        // Loop config items to set it value into newConfig\r\n        for (var key in config) {\r\n            // if baseConfig is set, only accept the baseconfig property\r\n            if (Object.keys(baseConfig).length !== 0 && !baseConfig.hasOwnProperty(key))\r\n                continue;\r\n            // var parse the config value\r\n            var val = this.parseValue(config[key]);\r\n            // set the newConfig property value\r\n            newConfig[key] = val;\r\n            // Exclusive for 'duration' or 'pulse' property, recheck the value\r\n            // If it's not a boolean, just set it to milisecond uint\r\n            if (key.match(/duration|pulse/)) {\r\n                newConfig[key] = typeof val != \"boolean\" ? val * 1000 : val;\r\n            }\r\n        }\r\n\r\n        // Finally, we can just merge the baseConfig (if any), with newConfig.\r\n        return Object.assign({}, baseConfig, newConfig);\r\n    }\r\n\r\n    /** Initial setup method */\r\n    registerEventListeners() {\r\n        /** Get all elements with class 'purecounter' */\r\n        var elements = this.elements;\r\n        /** Return if no elements */\r\n        if (elements.length === 0) return;\r\n\r\n        /** Run animateElements base on Intersection Support */\r\n        if (this.intersectionSupport) {\r\n            var intersectObserver = new IntersectionObserver(\r\n                this.animateElements.bind(this),\r\n                {\r\n                    root: null,\r\n                    rootMargin: \"20px\",\r\n                    threshold: 0.5,\r\n                }\r\n            );\r\n\r\n            elements.forEach((element) => {\r\n                intersectObserver.observe(element);\r\n            });\r\n        } else {\r\n            if (window.addEventListener) {\r\n                this.animateLegacy(elements);\r\n                window.addEventListener(\r\n                    \"scroll\",\r\n                    function (e) {\r\n                        this.animateLegacy(elements);\r\n                    },\r\n                    { passive: true }\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /** This legacy to make Purecounter use very lightweight & fast */\r\n    animateLegacy(elements) {\r\n        elements.forEach((element) => {\r\n            var config = this.parseConfig(element);\r\n            if (config.legacy === true && this.elementIsInView(element)) {\r\n                this.animateElements([element]);\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Main Element Count Animation */\r\n    animateElements(elements, observer) {\r\n        elements.forEach((element) => {\r\n            var elm = element.target || element; // Just make sure which element will be used\r\n            var elementConfig = this.parseConfig(elm); // Get config value on that element\r\n\r\n            // console.log(elementConfig);\r\n            // If duration is less than or equal zero, just format the 'end' value\r\n            if (elementConfig.duration <= 0) {\r\n                return (elm.innerHTML = this.formatNumber(\r\n                    elementConfig.end,\r\n                    elementConfig\r\n                ));\r\n            }\r\n\r\n            if (\r\n                (!observer && !this.elementIsInView(element)) ||\r\n                (observer && element.intersectionRatio < 0.5)\r\n            ) {\r\n                var value =\r\n                    elementConfig.start > elementConfig.end\r\n                        ? elementConfig.end\r\n                        : elementConfig.start;\r\n                return (elm.innerHTML = this.formatNumber(value, elementConfig));\r\n            }\r\n\r\n            // If duration is more than 0, then start the counter\r\n            setTimeout(() => {\r\n                return this.startCounter(elm, elementConfig);\r\n            }, elementConfig.delay);\r\n        });\r\n    }\r\n\r\n    /** This is the the counter method */\r\n    startCounter(element, config) {\r\n        // First, get the increments step\r\n        var incrementsPerStep =\r\n            (config.end - config.start) / (config.duration / config.delay);\r\n        // Next, set the counter mode (Increment or Decrement)\r\n        var countMode = \"inc\";\r\n\r\n        // Set mode to 'decrement' and 'increment step' to minus if start is larger than end\r\n        if (config.start > config.end) {\r\n            countMode = \"dec\";\r\n            incrementsPerStep *= -1;\r\n        }\r\n\r\n        // Next, determine the starting value\r\n        var currentCount = this.parseValue(config.start);\r\n        // And then print it's value to the page\r\n        element.innerHTML = this.formatNumber(currentCount, config);\r\n\r\n        // If the config 'once' is true, then set the 'duration' to 0\r\n        if (config.once === true) {\r\n            element.setAttribute(\"data-purecounter-duration\", 0);\r\n        }\r\n\r\n        // Now, start counting with counterWorker using Interval method based on delay\r\n        var counterWorker = setInterval(() => {\r\n            // First, determine the next value base on current value, increment value, and count mode\r\n            var nextNum = this.nextNumber(currentCount, incrementsPerStep, countMode);\r\n            // Next, print that value to the page\r\n            element.innerHTML = this.formatNumber(nextNum, config);\r\n            // Now set that value to the current value, because it's already printed\r\n            currentCount = nextNum;\r\n\r\n            // If the value is larger or less than the 'end' (base on mode), then  print the end value and stop the Interval\r\n            if (\r\n                (currentCount >= config.end && countMode === \"inc\") ||\r\n                (currentCount <= config.end && countMode === \"dec\")\r\n            ) {\r\n                element.innerHTML = this.formatNumber(config.end, config);\r\n                // If 'pulse' is set ignore the 'once' config\r\n                if (config.pulse) {\r\n                    // First set the 'duration' to zero\r\n                    element.setAttribute(\"data-purecounter-duration\", 0);\r\n                    // Next, use timeout to reset it duration back based on 'pulse' config\r\n                    setTimeout(() => {\r\n                        element.setAttribute(\r\n                            \"data-purecounter-duration\",\r\n                            config.duration / 1000\r\n                        );\r\n                    }, config.pulse);\r\n                }\r\n                // Now, we can close the conterWorker peacefully\r\n                clearInterval(counterWorker);\r\n            }\r\n        }, config.delay);\r\n    }\r\n\r\n    /** This method is to generate the element Config */\r\n    parseConfig(element) {\r\n        // Next, get all 'data-precounter-*' attributes value. Store to array\r\n        var configValues = [].filter.call(element.attributes, function (attr) {\r\n            return /^data-purecounter-/.test(attr.name);\r\n        });\r\n\r\n        // Now, we create element config as an object\r\n        var elementConfig =\r\n            configValues.length != 0\r\n                ? Object.assign(\r\n                      {},\r\n                      ...configValues.map(({ name, value }) => {\r\n                          var key = name.replace(\"data-purecounter-\", \"\").toLowerCase(),\r\n                              val = this.parseValue(value);\r\n\r\n                          return { [key]: val };\r\n                      })\r\n                  )\r\n                : {};\r\n\r\n        // Last setOptions and return\r\n        return this.setOptions(elementConfig, this.configOptions);\r\n    }\r\n\r\n    /** This method is to get the next number */\r\n    nextNumber(number, steps, mode = \"inc\") {\r\n        // First, get the exact value from the number and step (int or float)\r\n        number = this.parseValue(number);\r\n        steps = this.parseValue(steps);\r\n\r\n        // Last, get the next number based on current number, increment step, and count mode\r\n        // Always return it as float\r\n        return parseFloat(mode === \"inc\" ? number + steps : number - steps);\r\n    }\r\n\r\n    /** This method is to get the converted number */\r\n    convertNumber(number, config) {\r\n        /** Use converter if filesizing or currency is on */\r\n        if (config.filesizing || config.currency) {\r\n            number = Math.abs(Number(number)); // Get the absolute value of number\r\n\r\n            var baseNumber = 1000, // Base multiplying treshold\r\n                symbol =\r\n                    config.currency && typeof config.currency === \"string\"\r\n                        ? config.currency\r\n                        : \"\", // Set the Currency Symbol (if any)\r\n                limit = config.decimals || 1, // Set the decimal limit (default is 1)\r\n                uint = [\"\", \"K\", \"M\", \"B\", \"T\"], // Number uint based exponent threshold\r\n                value = \"\"; // Define value variable\r\n\r\n            /** Changes base number and its uint for filesizing */\r\n            if (config.filesizing) {\r\n                baseNumber = 1024; // Use 1024 instead of 1000\r\n                uint = [\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"]; // Change to 'bytes' uint\r\n            }\r\n\r\n            /** Set value based on the threshold */\r\n            for (var i = 4; i >= 0; i--) {\r\n                // If the exponent is 0\r\n                if (i === 0) value = `${number.toFixed(limit)} ${uint[i]}`;\r\n                // If the exponent is above zero\r\n                if (number >= this.getFilesizeThreshold(baseNumber, i)) {\r\n                    value = `${(\r\n                        number / this.getFilesizeThreshold(baseNumber, i)\r\n                    ).toFixed(limit)} ${uint[i]}`;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Apply symbol before the value and return it as string\r\n            return symbol + value;\r\n        } else {\r\n            /** Return its value as float if not using filesizing or currency*/\r\n            return parseFloat(number);\r\n        }\r\n    }\r\n\r\n    /** This method will get the given base.  */\r\n    getFilesizeThreshold(baseNumber, index) {\r\n        return Math.pow(baseNumber, index);\r\n    }\r\n\r\n    /** This method is to get the last formated number */\r\n    applySeparator(value, config) {\r\n        // Get replaced value based on it's separator/symbol.\r\n        function replacedValue(val, separator) {\r\n            // Well this is my regExp for detecting the Thausands Separator\r\n            // I use 3 groups to determine it's separator\r\n            // THen the group 4 is to get the decimals value\r\n            var separatorRegExp =\r\n                /^(?:(\\d{1,3},(?:\\d{1,3},?)*)|(\\d{1,3}\\.(?:\\d{1,3}\\.?)*)|(\\d{1,3}(?:\\s\\d{1,3})*))([\\.,]?\\d{0,2}?)$/gi;\r\n\r\n            return val.replace(separatorRegExp, function (match, g1, g2, g3, g4) {\r\n                // set initial result value\r\n                var result = \"\",\r\n                    sep = \"\";\r\n                if (g1 !== undefined) {\r\n                    // Group 1 is using comma as thausands separator, and period as decimal separator\r\n                    result = g1.replace(new RegExp(/,/gi, \"gi\"), separator);\r\n                    sep = \",\";\r\n                } else if (g2 !== undefined) {\r\n                    // Group 2 is using period as thausands separator, and comma as decimal separator\r\n                    result = g2.replace(new RegExp(/\\./gi, \"gi\"), separator);\r\n                } else if (g3 !== undefined) {\r\n                    // Group 3 is using space as thausands separator, and comma as decimal separator\r\n                    result = g3.replace(new RegExp(/ /gi, \"gi\"), separator);\r\n                }\r\n                if (g4 !== undefined) {\r\n                    var decimal = sep !== \",\" ? (separator !== \",\" ? \",\" : \".\") : \".\";\r\n                    result += g4.replace(new RegExp(/\\.|,/gi, \"gi\"), decimal);\r\n                }\r\n                // Returning result value;\r\n                return result;\r\n            });\r\n        }\r\n        // If config formater is not false, then apply separator\r\n        if (config.formater) {\r\n            // Now get the separator symbol\r\n            var symbol = config.separator // if config separator is setted\r\n                ? typeof config.separator === \"string\" // Check the type of value\r\n                    ? config.separator // If it's type is string, then apply it's value\r\n                    : \",\" // If it's not string (boolean), then apply comma as default separator\r\n                : \"\";\r\n            // Special exception when locale is not 'en-US' but separator value is 'true'\r\n            // Use it's default locale thausands separator.\r\n            if (config.formater !== \"en-US\" && config.separator === true) {\r\n                return value;\r\n            }\r\n            // Return the replaced Value based on it's symbol\r\n            return replacedValue(value, symbol);\r\n        }\r\n        // If config formater is false, then return it's default value\r\n        return value;\r\n    }\r\n\r\n    /** This method is to get formated number to be printed in the page */\r\n    formatNumber(number, config) {\r\n        // This is the configuration for 'toLocaleString' method\r\n        var strConfig = {\r\n            minimumFractionDigits: config.decimals,\r\n            maximumFractionDigits: config.decimals,\r\n        };\r\n        // Get locale from config formater\r\n        var locale = typeof config.formater === \"string\" ? config.formater : undefined;\r\n\r\n        // Set and convert the number base on its config.\r\n        number = this.convertNumber(number, config);\r\n\r\n        // Now format the number to string base on it's locale\r\n        number = config.formater\r\n            ? number.toLocaleString(locale, strConfig)\r\n            : parseInt(number).toString();\r\n        // Last, apply the number separator using number as string\r\n        return this.applySeparator(number, config);\r\n    }\r\n\r\n    getLocaleSeparator() {\r\n        var regExp =\r\n            /^(?:(\\d{1,3}(?:,\\d{1,3})*(?:\\.\\d{0,3})?)|(\\d{1,3}(?:\\.\\d{1,3})*(?:,\\d{0,3})?)|(\\d{1,3}(?:\\s\\d{1,3})*(?:,\\d{0,3})?))$/i;\r\n        return;\r\n    }\r\n\r\n    /** This method is to get the parsed value */\r\n    parseValue(data) {\r\n        // If number with dot (.), will be parsed as float\r\n        if (/^[0-9]+\\.[0-9]+$/.test(data)) {\r\n            return parseFloat(data);\r\n        }\r\n        // If just number, will be parsed as integer\r\n        if (/^[0-9]+$/.test(data)) {\r\n            return parseInt(data);\r\n        }\r\n        // If it's boolean string, will be parsed as boolean\r\n        if (/^true|false/i.test(data)) {\r\n            return /^true/i.test(data);\r\n        }\r\n        // Return it's value as default\r\n        return data;\r\n    }\r\n\r\n    /** This method is to detect the element is in view or not. */\r\n    elementIsInView(element) {\r\n        var top = element.offsetTop;\r\n        var left = element.offsetLeft;\r\n        var width = element.offsetWidth;\r\n        var height = element.offsetHeight;\r\n\r\n        while (element.offsetParent) {\r\n            element = element.offsetParent;\r\n            top += element.offsetTop;\r\n            left += element.offsetLeft;\r\n        }\r\n\r\n        return (\r\n            top >= window.pageYOffset &&\r\n            left >= window.pageXOffset &&\r\n            top + height <= window.pageYOffset + window.innerHeight &&\r\n            left + width <= window.pageXOffset + window.innerWidth\r\n        );\r\n    }\r\n\r\n    /** Just some condition to check browser Intersection Support */\r\n    intersectionListenerSupported() {\r\n        return (\r\n            \"IntersectionObserver\" in window &&\r\n            \"IntersectionObserverEntry\" in window &&\r\n            \"intersectionRatio\" in window.IntersectionObserverEntry.prototype\r\n        );\r\n    }\r\n}\r\n","// require PureCounter from './js/purecounter.js';\r\n// Store it as consant\r\nconst PureCounter = require('./js/purecounter').default;\r\n\r\n// Set module Export to PureCounter class, so it can be initialize as class\r\nmodule.exports = PureCounter;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(634);\n"],"names":["root","factory","exports","module","define","amd","self","PureCounter","options","this","defaults","start","end","duration","delay","once","pulse","decimals","legacy","filesizing","currency","separator","formater","selector","configOptions","setOptions","elements","document","querySelectorAll","intersectionSupport","intersectionListenerSupported","registerEventListeners","config","baseConfig","newConfig","key","Object","keys","length","hasOwnProperty","val","parseValue","match","assign","intersectObserver","IntersectionObserver","animateElements","bind","rootMargin","threshold","forEach","element","observe","window","addEventListener","animateLegacy","e","passive","parseConfig","elementIsInView","observer","elm","target","elementConfig","innerHTML","formatNumber","intersectionRatio","value","setTimeout","startCounter","incrementsPerStep","countMode","currentCount","setAttribute","counterWorker","setInterval","nextNum","nextNumber","clearInterval","configValues","filter","call","attributes","attr","test","name","map","replace","toLowerCase","number","steps","mode","parseFloat","Math","abs","Number","baseNumber","symbol","limit","uint","i","toFixed","getFilesizeThreshold","index","pow","g1","g2","g3","g4","result","sep","undefined","RegExp","decimal","strConfig","minimumFractionDigits","maximumFractionDigits","locale","convertNumber","toLocaleString","parseInt","toString","applySeparator","data","top","offsetTop","left","offsetLeft","width","offsetWidth","height","offsetHeight","offsetParent","pageYOffset","pageXOffset","innerHeight","innerWidth","IntersectionObserverEntry","prototype","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","o","defineProperty","enumerable","get","obj","prop"],"sourceRoot":""}